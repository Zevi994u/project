var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var ygopro_deck_encode_exports = {};
__export(ygopro_deck_encode_exports, {
  default: () => YGOProDeck
});
module.exports = __toCommonJS(ygopro_deck_encode_exports);

// src/base64.ts
function toBase64Url(bytes) {
  const base64 = typeof Buffer !== "undefined" ? Buffer.from(bytes).toString("base64") : btoa(String.fromCharCode(...bytes));
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function fromBase64Url(encoded) {
  const base64 = encoded.replace(/-/g, "+").replace(/_/g, "/");
  const padded = base64.padEnd(base64.length + (4 - base64.length % 4) % 4, "=");
  if (typeof Buffer !== "undefined") {
    return Uint8Array.from(Buffer.from(padded, "base64"));
  }
  const binary = atob(padded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}

// src/utils.ts
function countItems(arr) {
  const map = /* @__PURE__ */ new Map();
  for (const item of arr) {
    map.set(item, (map.get(item) || 0) + 1);
  }
  return map;
}
var BufferCursor = class {
  constructor(bufOrLength) {
    this.pointer = 0;
    if (typeof bufOrLength === "number") {
      this.buffer = new Uint8Array(bufOrLength);
    } else {
      this.buffer = bufOrLength;
    }
  }
  /**
   * 安全地将 pointer 向前移动指定字节数。
   * @param bytes 要移动的字节数
   * @returns 原来 pointer 的值
   * @throws RangeError 如果越界
   */
  increasePointer(bytes) {
    const old = this.pointer;
    const next = old + bytes;
    if (next > this.buffer.length) {
      throw new RangeError(
        `Pointer overflow: tried to move to ${next}, but buffer length is ${this.buffer.length}`
      );
    }
    this.pointer = next;
    return old;
  }
};
var BufferWriter = class extends BufferCursor {
  constructor(length) {
    super(length);
  }
  writeUint32LE(value) {
    const idx = this.increasePointer(4);
    this.buffer[idx] = value & 255;
    this.buffer[idx + 1] = value >>> 8 & 255;
    this.buffer[idx + 2] = value >>> 16 & 255;
    this.buffer[idx + 3] = value >>> 24 & 255;
    return this;
  }
  writeUint32BE(value) {
    const idx = this.increasePointer(4);
    this.buffer[idx] = value >>> 24 & 255;
    this.buffer[idx + 1] = value >>> 16 & 255;
    this.buffer[idx + 2] = value >>> 8 & 255;
    this.buffer[idx + 3] = value & 255;
    return this;
  }
  writeUint16LE(value) {
    const idx = this.increasePointer(2);
    this.buffer[idx] = value & 255;
    this.buffer[idx + 1] = value >>> 8 & 255;
    return this;
  }
  writeUint16BE(value) {
    const idx = this.increasePointer(2);
    this.buffer[idx] = value >>> 8 & 255;
    this.buffer[idx + 1] = value & 255;
    return this;
  }
  writeUint8(value) {
    const idx = this.increasePointer(1);
    this.buffer[idx] = value & 255;
    return this;
  }
  writeString(str) {
    for (let i = 0; i < str.length; i++) {
      const idx = this.increasePointer(1);
      this.buffer[idx] = str.charCodeAt(i);
    }
    return this;
  }
};
var BufferReader = class extends BufferCursor {
  constructor(buf) {
    super(buf);
  }
  readUint32LE() {
    const idx = this.increasePointer(4);
    const b = this.buffer;
    return (b[idx] | b[idx + 1] << 8 | b[idx + 2] << 16 | b[idx + 3] << 24) >>> 0;
  }
  readUint32BE() {
    const idx = this.increasePointer(4);
    const b = this.buffer;
    return (b[idx] << 24 | b[idx + 1] << 16 | b[idx + 2] << 8 | b[idx + 3]) >>> 0;
  }
  readUint16LE() {
    const idx = this.increasePointer(2);
    const b = this.buffer;
    return b[idx] | b[idx + 1] << 8;
  }
  readUint16BE() {
    const idx = this.increasePointer(2);
    const b = this.buffer;
    return b[idx] << 8 | b[idx + 1];
  }
  readUint8() {
    const idx = this.increasePointer(1);
    return this.buffer[idx];
  }
  readString(length) {
    let s = "";
    for (let i = 0; i < length; i++) {
      const idx = this.increasePointer(1);
      s += String.fromCharCode(this.buffer[idx]);
    }
    return s;
  }
  readRemaining() {
    const remaining = this.buffer.length - this.pointer;
    const idx = this.increasePointer(remaining);
    return this.buffer.subarray(idx, this.buffer.length);
  }
};

// src/ydke.ts
function base64ToUint32Array(base64) {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  const view = new DataView(bytes.buffer);
  const result = [];
  for (let i = 0; i < bytes.length; i += 4) {
    result.push(view.getUint32(i, true));
  }
  return result;
}
function uint32ArrayToBase64(data) {
  const buffer = new ArrayBuffer(data.length * 4);
  const view = new DataView(buffer);
  data.forEach((val, i) => view.setUint32(i * 4, val, true));
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function toYdkeURL(deck) {
  return "ydke://" + uint32ArrayToBase64(deck.main) + "!" + uint32ArrayToBase64(deck.extra) + "!" + uint32ArrayToBase64(deck.side) + "!";
}
function fromYdkeURL(ydke) {
  if (!ydke.startsWith("ydke://")) {
    throw new Error("Invalid ydke:// URI");
  }
  const [mainStr, extraStr, sideStr] = ydke.slice(7).split("!");
  if (mainStr === void 0 || extraStr === void 0 || sideStr === void 0) {
    throw new Error("Incomplete ydke:// URI");
  }
  return {
    main: base64ToUint32Array(mainStr),
    extra: base64ToUint32Array(extraStr),
    side: base64ToUint32Array(sideStr)
  };
}

// src/ygom.ts
var QUERY_YGO_TYPE = "ygotype";
var QUERY_VERSION = "v";
var ARG_DECK = "deck";
var QUERY_DECK = "d";
var QUERY_NAME = "name";
var URL_SCHEME_HTTP = "http";
var URL_HOST_DECK = "deck.ourygo.top";
var BitWriter = class {
  constructor() {
    this.buffer = [];
    this.current = 0;
    this.bitPos = 0;
  }
  writeBits(value, length) {
    while (length > 0) {
      const remain = 8 - this.bitPos;
      const take = Math.min(remain, length);
      const shift = length - take;
      this.current |= (value >>> shift & (1 << take) - 1) << remain - take;
      this.bitPos += take;
      length -= take;
      if (this.bitPos === 8) {
        this.buffer.push(this.current);
        this.current = 0;
        this.bitPos = 0;
      }
    }
  }
  finish() {
    if (this.bitPos > 0)
      this.buffer.push(this.current);
    return new Uint8Array(this.buffer);
  }
};
var BitReader = class {
  constructor(bytes) {
    this.bytes = bytes;
    this.index = 0;
    this.bitPos = 0;
  }
  readBits(length) {
    let result = 0;
    while (length > 0) {
      const remain = 8 - this.bitPos;
      const take = Math.min(remain, length);
      const bits = this.bytes[this.index] >>> remain - take & (1 << take) - 1;
      result = result << take | bits;
      this.bitPos += take;
      length -= take;
      if (this.bitPos === 8) {
        this.bitPos = 0;
        this.index++;
      }
    }
    return result;
  }
};
function countUnique(cards) {
  let count = 0;
  for (let i = 0; i < cards.length; ) {
    const id = cards[i];
    count++;
    while (i < cards.length && cards[i] === id)
      i++;
  }
  return count;
}
function toYGOMobileDeckURL(main, extra, side, customParams = {}) {
  const mNum = countUnique(main);
  const eNum = countUnique(extra);
  const sNum = countUnique(side);
  const writer = new BitWriter();
  writer.writeBits(mNum, 8);
  writer.writeBits(eNum, 4);
  writer.writeBits(sNum, 4);
  const encodeSection = (cards) => {
    for (let i = 0; i < cards.length; ) {
      const id = cards[i];
      let count = 1;
      while (i + count < cards.length && cards[i + count] === id && count < 3)
        count++;
      const prefix = count === 2 ? 2 : count === 3 ? 3 : 1;
      writer.writeBits(prefix, 2);
      writer.writeBits(id, 27);
      i += count;
    }
  };
  encodeSection(main);
  encodeSection(extra);
  encodeSection(side);
  const encoded = toBase64Url(writer.finish());
  const searchParams = new URLSearchParams();
  for (const [k, v] of Object.entries(customParams)) {
    searchParams.set(k, v);
  }
  searchParams.set(QUERY_YGO_TYPE, ARG_DECK);
  searchParams.set(QUERY_VERSION, "1");
  searchParams.set(QUERY_DECK, encoded);
  return `${URL_SCHEME_HTTP}://${URL_HOST_DECK}?${searchParams.toString()}`;
}
function fromYGOMobileDeckURL(uri) {
  var _a;
  const url = new URL(uri);
  if (url.searchParams.get(QUERY_YGO_TYPE) !== ARG_DECK) {
    throw new Error("Invalid deck URL");
  }
  const encoded = url.searchParams.get(QUERY_DECK);
  if (!encoded)
    throw new Error("Missing deck data");
  const bytes = fromBase64Url(encoded);
  const reader = new BitReader(bytes);
  const mNum = reader.readBits(8);
  const eNum = reader.readBits(4);
  const sNum = reader.readBits(4);
  const total = mNum + eNum + sNum;
  const result = {
    main: [],
    extra: [],
    side: []
  };
  for (let i = 0; i < total; i++) {
    const prefix = reader.readBits(2);
    const count = prefix === 2 ? 2 : prefix === 3 ? 3 : 1;
    const id = reader.readBits(27);
    const target = i < mNum ? result.main : i < mNum + eNum ? result.extra : result.side;
    for (let j = 0; j < count; j++) {
      target.push(id);
    }
  }
  return {
    ...result,
    name: (_a = url.searchParams.get(QUERY_NAME)) != null ? _a : void 0
  };
}

// index.ts
var YGOProDeck = class {
  constructor() {
    this.main = [];
    this.extra = [];
    this.side = [];
  }
  bufferLength() {
    const counted = [this.main, this.extra, this.side].map(countItems);
    return counted.reduce((a, b) => a + b.size * 4, 0);
  }
  toUint8Array() {
    const counted = [this.main, this.extra, this.side].map(countItems);
    const writer = new BufferWriter(
      counted.reduce((a, b) => a + b.size * 4, 0)
    );
    const writeCards = (countMap, type) => {
      for (const [id, count] of countMap.entries()) {
        if (count > 4) {
          throw new Error(`Too many cards: ${id}`);
        }
        const value = id & 268435455 | type << 28 | count - 1 << 30;
        writer.writeUint32LE(value);
      }
    };
    counted.forEach(writeCards);
    return writer.buffer;
  }
  toEncodedString() {
    return toBase64Url(this.toUint8Array());
  }
  toString() {
    return this.toEncodedString();
  }
  fromUint8Array(buf) {
    for (let i = 0; i < buf.length - 3; i += 4) {
      const value = buf[i] | buf[i + 1] << 8 | buf[i + 2] << 16 | buf[i + 3] << 24;
      const id = value & 268435455;
      const type = value >>> 28 & 3;
      const count = (value >>> 30 & 3) + 1;
      const cards = [this.main, this.extra, this.side][type];
      for (let j = 0; j < count; j++) {
        cards.push(id);
      }
    }
    return this;
  }
  static fromUint8Array(buf) {
    return new YGOProDeck().fromUint8Array(buf);
  }
  fromEncodedString(str) {
    return this.fromUint8Array(fromBase64Url(str));
  }
  static fromEncodedString(str) {
    return new YGOProDeck().fromEncodedString(str);
  }
  toYdkString() {
    return [
      "#created by ygopro-deck-encode",
      "#main",
      ...this.main.map((id) => id.toString()),
      "#extra",
      ...this.extra.map((id) => id.toString()),
      "!side",
      ...this.side.map((id) => id.toString())
    ].join("\n");
  }
  fromYdkString(str) {
    const lines = str.split(/\r?\n/);
    let current = this.main;
    for (const _line of lines) {
      const line = _line.trim();
      if (line === "#main") {
        current = this.main;
      }
      if (line === "#extra") {
        current = this.extra;
      }
      if (line === "!side") {
        current = this.side;
      }
      if (line.match(/^\d+$/)) {
        current.push(parseInt(line, 10));
      }
    }
    return this;
  }
  static fromYdkString(str) {
    return new YGOProDeck().fromYdkString(str);
  }
  fromUpdateDeckPayload(buf, isExtraDeckCard = () => false) {
    const reader = new BufferReader(buf);
    const mainc = reader.readUint32LE();
    const sidec = reader.readUint32LE();
    this.main = [];
    this.extra = [];
    this.side = [];
    for (let i = 0; i < mainc; i++) {
      const id = reader.readUint32LE();
      if (isExtraDeckCard(id, i, mainc)) {
        this.extra.push(id);
      } else {
        this.main.push(id);
      }
    }
    for (let i = 0; i < sidec; i++) {
      const id = reader.readUint32LE();
      this.side.push(id);
    }
    return this;
  }
  static fromUpdateDeckPayload(buf, isExtraDeckCard = () => false) {
    return new YGOProDeck().fromUpdateDeckPayload(buf, isExtraDeckCard);
  }
  toUpdateDeckPayload() {
    const cards = [...this.main, ...this.extra, ...this.side];
    const writer = new BufferWriter(cards.length * 4 + 8).writeUint32LE(this.main.length + this.extra.length).writeUint32LE(this.side.length);
    cards.forEach((id) => writer.writeUint32LE(id));
    return writer.buffer;
  }
  fromYGOMobileDeckURL(uri) {
    const parsed = fromYGOMobileDeckURL(uri);
    this.main = parsed.main;
    this.extra = parsed.extra;
    this.side = parsed.side;
    this.name = parsed.name;
    return this;
  }
  static fromYGOMobileDeckURL(uri) {
    return new YGOProDeck().fromYGOMobileDeckURL(uri);
  }
  toYGOMobileDeckURL() {
    return toYGOMobileDeckURL(this.main, this.extra, this.side, this.name && {
      name: this.name
    });
  }
  fromYdkeURL(uri) {
    const parsed = fromYdkeURL(uri);
    this.main = parsed.main;
    this.extra = parsed.extra;
    this.side = parsed.side;
    return this;
  }
  static fromYdkeURL(uri) {
    return new YGOProDeck().fromYdkeURL(uri);
  }
  toYdkeURL() {
    return toYdkeURL({
      main: this.main,
      extra: this.extra,
      side: this.side
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.cjs.map
