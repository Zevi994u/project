import { BaseDriver } from './base-driver';
import { AnyClass, AragamiOptions, Awaitable, ClassType } from './def';
import { MayBeArray } from './utility/utility';
import { PartialDeep } from './utility/partial-deep';
export declare class Aragami {
    private options;
    readonly driver: BaseDriver;
    constructor(options?: AragamiOptions);
    private getBaseKey;
    private getKey;
    private getTTL;
    private encode;
    private decode;
    get<T>(cl: ClassType<T>, key: string): Promise<T>;
    set<T>(o: T, options?: {
        ttl?: number;
        key?: string;
        prototype?: ClassType<T>;
    }): Promise<T>;
    set<T>(prototype: ClassType<T>, o: PartialDeep<T>, options?: {
        ttl?: number;
        key?: string;
    }): Promise<T>;
    has(base: AnyClass | string, key: string): Promise<boolean>;
    has(base: any): Promise<boolean>;
    del(base: AnyClass | string, key: string): Promise<boolean>;
    del(base: any): Promise<boolean>;
    clear(base: AnyClass | string, prefix?: string): Promise<void>;
    keys(base: AnyClass | string, prefix?: string): Promise<string[]>;
    values<T>(cl: ClassType<T>, prefix?: string): Promise<T[]>;
    entries<T>(cl: ClassType<T>, prefix?: string): Promise<[string, T][]>;
    cache<T>(cl: ClassType<T>, keyOrMeta: string | T, cb: () => Awaitable<T>): Promise<T>;
    useCache<T, A extends any[]>(cl: ClassType<T>, cb: (...args: A) => Awaitable<T>, keySource: (...args: A) => Awaitable<string | T>): (...args: A) => Promise<T>;
    private getLockKeys;
    lock<R>(keys: MayBeArray<string | any>, cb: () => Awaitable<R>): Promise<R>;
    isFree(keys: MayBeArray<string | any>): Promise<boolean>;
    useLock<A extends any[], R>(cb: (...args: A) => R, keySource: (...args: A) => Awaitable<MayBeArray<string | any>>): (...args: A) => Promise<R>;
    destroy(): Promise<void>;
    isQueueEmpty<T>(cl: ClassType<T>, key?: string): Promise<boolean>;
    queueLength<T>(cl: ClassType<T>, key?: string): Promise<number>;
    queueItems<T>(cl: ClassType<T>, key?: string): Promise<T[]>;
    queueAdd<T>(o: T, options?: {
        key?: string;
        prototype?: ClassType<T>;
        prior?: boolean;
    }): Promise<T>;
    queueAdd<T>(prototype: ClassType<T>, o: PartialDeep<T>, options?: {
        key?: string;
        prior?: boolean;
    }): Promise<T>;
    queueGather<T>(prototype: ClassType<T>, key?: string): Promise<T>;
    queueGatherBlocking<T>(prototype: ClassType<T>, key?: string): Promise<T>;
    queueClear<T>(prototype: ClassType<T>, key?: string): Promise<void>;
    queueResumeAll<T>(prototype: ClassType<T>, key?: string, prior?: boolean): Promise<void>;
    runQueueOnce<T, R>(prototype: ClassType<T>, cb: (item: T) => Awaitable<R>, key?: string): Promise<R>;
}
