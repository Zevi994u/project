"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Aragami = void 0;
const redis_1 = require("./drivers/redis");
const memory_1 = require("./drivers/memory");
const metadata_1 = require("./metadata");
const class_transformer_1 = require("class-transformer");
const encoded_buffer_1 = require("encoded-buffer");
const utility_1 = require("./utility/utility");
const lodash_1 = __importDefault(require("lodash"));
class Aragami {
    constructor(options = {}) {
        this.options = options;
        this.driver = options.redis
            ? new redis_1.RedisDriver(options.redis)
            : new memory_1.MemoryDriver();
    }
    getBaseKey(o) {
        if (typeof o === 'string') {
            return o;
        }
        const keyFromMetadata = metadata_1.reflector.get('AragamiCachePrefix', o);
        if (keyFromMetadata) {
            return keyFromMetadata;
        }
        const keyFromConstructor = typeof o === 'function' ? o.name : o.constructor?.name;
        if (keyFromConstructor) {
            return keyFromConstructor;
        }
        return 'default';
    }
    async getKey(o, prototype, fallback) {
        if (typeof o === 'string') {
            return o;
        }
        if (prototype) {
            o = (0, class_transformer_1.plainToInstance)(prototype, o);
        }
        const keyTransformer = metadata_1.reflector.get('AragamiCacheKey', o);
        if (!keyTransformer) {
            if (fallback) {
                return fallback;
            }
            throw new Error(`No key metadata found for ${o.constructor.name}`);
        }
        return await keyTransformer(o);
    }
    getTTL(o) {
        return metadata_1.reflector.get('AragamiCacheTTL', o) ?? this.options.defaultTTL ?? 0;
    }
    encode(o) {
        return (0, encoded_buffer_1.encode)((0, class_transformer_1.instanceToPlain)(o));
    }
    decode(cl, value) {
        return (0, class_transformer_1.plainToInstance)(cl, (0, encoded_buffer_1.decode)(value)[0]);
    }
    async get(cl, key) {
        const value = await this.driver.get(this.getBaseKey(cl), key);
        if (!value) {
            return;
        }
        return this.decode(cl, value);
    }
    async set(...args) {
        let prototype;
        let o;
        let options;
        const firstArg = args[0];
        if (typeof firstArg === 'function') {
            prototype = firstArg;
            o = args[1];
            options = args[2] || {};
        }
        else {
            o = firstArg;
            options = args[1] || {};
            prototype = options.prototype;
        }
        if (!o) {
            return o;
        }
        if (prototype) {
            o = (0, class_transformer_1.plainToInstance)(prototype, o);
        }
        const buf = this.encode(o);
        await this.driver.set(this.getBaseKey(o), options.key || (await this.getKey(o)), buf, options.ttl ?? this.getTTL(o));
        return o;
    }
    async has(base, key) {
        return this.driver.has(this.getBaseKey(base), key || (await this.getKey(base)));
    }
    async del(base, key) {
        return this.driver.del(this.getBaseKey(base), key || (await this.getKey(base)));
    }
    async clear(base, prefix) {
        return this.driver.clear(this.getBaseKey(base), prefix);
    }
    async keys(base, prefix) {
        return this.driver.keys(this.getBaseKey(base), prefix);
    }
    async values(cl, prefix) {
        const buffers = await this.driver.values(this.getBaseKey(cl), prefix);
        return buffers.map((buf) => this.decode(cl, buf));
    }
    async entries(cl, prefix) {
        const entries = await this.driver.entries(this.getBaseKey(cl));
        return entries.map(([key, buf]) => [key, this.decode(cl, buf)]);
    }
    async cache(cl, keyOrMeta, cb) {
        const key = await this.getKey(keyOrMeta, cl);
        if (!key) {
            return cb();
        }
        const cachedValue = await this.get(cl, key);
        if (cachedValue != null) {
            return cachedValue;
        }
        const value = await cb();
        if (value != null) {
            await this.set(value, { key, prototype: cl });
        }
        return value;
    }
    useCache(cl, cb, keySource) {
        return async (...args) => {
            const keyMeta = await keySource(...args);
            return this.cache(cl, keyMeta, () => cb(...args));
        };
    }
    async getLockKeys(o) {
        if (typeof o === 'string') {
            return [o];
        }
        const baseKey = this.getBaseKey(o);
        const keyTransformers = metadata_1.reflector.getArray('AragamiLockKeys', o);
        const actualKeys = await Promise.all(keyTransformers.map((fn) => fn(o)));
        return lodash_1.default.compact(actualKeys.flatMap((mayBeKeyArray) => (0, utility_1.makeArray)(mayBeKeyArray).map((key) => `${baseKey}:${key}`)));
    }
    async lock(keys, cb) {
        const keyMeta = (0, utility_1.makeArray)(keys);
        const actualKeys = (await Promise.all(keyMeta.map((o) => this.getLockKeys(o)))).flat();
        if (!keys.length) {
            return cb();
        }
        return this.driver.lock(actualKeys, async () => await cb());
    }
    async isFree(keys) {
        const keyMeta = (0, utility_1.makeArray)(keys);
        const actualKeys = (await Promise.all(keyMeta.map((o) => this.getLockKeys(o)))).flat();
        if (!keys.length) {
            return true;
        }
        return this.driver.isFree(actualKeys);
    }
    useLock(cb, keySource) {
        return async (...args) => {
            const keys = await keySource(...args);
            return this.lock(keys, () => cb(...args));
        };
    }
    async destroy() {
        try {
            await this.driver.destroy();
        }
        catch (e) { }
    }
    async isQueueEmpty(cl, key = 'default') {
        return this.driver.isQueueEmpty(this.getBaseKey(cl) + ':' + key);
    }
    async queueLength(cl, key = 'default') {
        return this.driver.queueLength(this.getBaseKey(cl) + ':' + key);
    }
    async queueItems(cl, key = 'default') {
        const items = await this.driver.queueItems(this.getBaseKey(cl) + ':' + key);
        return items.map((buf) => this.decode(cl, buf));
    }
    async queueAdd(...args) {
        let prototype;
        let o;
        let options;
        const firstArg = args[0];
        if (typeof firstArg === 'function') {
            prototype = firstArg;
            o = args[1];
            options = args[2] || {};
        }
        else {
            o = firstArg;
            options = args[1] || {};
            prototype = options.prototype;
        }
        if (!o) {
            return o;
        }
        if (prototype) {
            o = (0, class_transformer_1.plainToInstance)(prototype, o);
        }
        const buf = this.encode(o);
        const key = this.getBaseKey(o) +
            ':' +
            (options.key || (await this.getKey(o, undefined, 'default')));
        await this.driver.queueAdd(key, buf, options.prior);
        return o;
    }
    async queueGather(prototype, key = 'default') {
        const baseKey = this.getBaseKey(prototype);
        const buffer = await this.driver.queueGather(baseKey + ':' + key);
        if (!buffer) {
            return;
        }
        return this.decode(prototype, buffer);
    }
    async queueGatherBlocking(prototype, key = 'default') {
        const baseKey = this.getBaseKey(prototype);
        const buffer = await this.driver.queueGatherBlocking(baseKey + ':' + key);
        return this.decode(prototype, buffer);
    }
    async queueClear(prototype, key = 'default') {
        const baseKey = this.getBaseKey(prototype);
        await this.driver.queueClear(baseKey + ':' + key);
    }
    async queueResumeAll(prototype, key = 'default', prior) {
        const baseKey = this.getBaseKey(prototype);
        await this.driver.queueResumeAll(baseKey + ':' + key, prior);
    }
    async runQueueOnce(prototype, cb, key = 'default') {
        const baseKey = this.getBaseKey(prototype);
        const buffer = await this.driver.queueGatherBlocking(baseKey + ':' + key);
        const object = this.decode(prototype, buffer);
        try {
            const res = await cb(object);
            await this.driver.queueAck(baseKey + ':' + key, buffer);
            return res;
        }
        catch (e) {
            await this.driver.queueResume(baseKey + ':' + key, buffer, true);
            throw e;
        }
    }
}
exports.Aragami = Aragami;
//# sourceMappingURL=aragami.js.map