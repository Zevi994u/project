"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDriver = void 0;
class BaseDriver {
    usingKey(baseKey, key) {
        return `${baseKey}:${key}`;
    }
    async get(baseKey, key) {
        return;
    }
    async has(baseKey, key) {
        return !!(await this.get(baseKey, key));
    }
    async set(baseKey, key, value, ttl) { }
    async del(baseKey, key) {
        return false;
    }
    async keys(baseKey, prefix) {
        return [];
    }
    async values(baseKey, prefix) {
        const keys = await this.keys(baseKey, prefix);
        return Promise.all(keys.map((key) => this.get(baseKey, key)));
    }
    async entries(baseKey, prefix) {
        const keys = await this.keys(baseKey, prefix);
        return Promise.all(keys.map(async (key) => [key, await this.get(baseKey, key)]));
    }
    async clear(baseKey, prefix) {
        const keys = await this.keys(baseKey, prefix);
        await Promise.all(keys.map((key) => this.del(baseKey, key)));
    }
    lock(keys, cb) {
        return cb();
    }
    async isFree(keys) {
        return true;
    }
    async destroy() { }
    async isQueueEmpty(key) {
        return (await this.queueLength(key)) === 0;
    }
    async queueLength(key) {
        return (await this.queueItems(key)).length;
    }
    async queueItems(key) {
        return [];
    }
    async queueAdd(key, value, prior) { }
    async queueGather(key) {
        return;
    }
    async queueGatherBlocking(key) {
        while (true) {
            const value = await this.queueGather(key);
            if (value) {
                return value;
            }
            await new Promise((resolve) => setTimeout(resolve, 10));
        }
    }
    async queueAck(key, value) {
        return;
    }
    async queueResume(key, value, prior) {
        return;
    }
    async queueResumeAll(key, prior) {
        return;
    }
    async queueClear(key) { }
}
exports.BaseDriver = BaseDriver;
//# sourceMappingURL=base-driver.js.map