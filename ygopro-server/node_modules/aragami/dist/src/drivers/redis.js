"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisDriver = void 0;
const base_driver_1 = require("../base-driver");
const ioredis_1 = __importDefault(require("ioredis"));
const redlock_1 = require("@sesamecare-oss/redlock");
const generic_pool_1 = require("generic-pool");
const better_lock_1 = __importDefault(require("better-lock"));
class RedisDriver extends base_driver_1.BaseDriver {
    constructor(options) {
        super();
        this.options = options;
        this.pool = (0, generic_pool_1.createPool)({
            create: async () => {
                const redis = await this.createRedisClient();
                return {
                    redis,
                    // redlock: new Redlock([redis], this.options.lock),
                };
            },
            destroy: async ({ redis }) => {
                await redis.quit();
            },
        });
        this.betterLock = new better_lock_1.default();
        this.quitted = false;
        this.waitingBlockingProms = new Map();
    }
    async createRedisClient() {
        let redis;
        if (this.options.uri) {
            redis = new ioredis_1.default(this.options.uri);
        }
        else {
            redis = new ioredis_1.default(this.options);
        }
        // await redis.connect();
        return redis;
    }
    async useTempRedisClient(cb) {
        const redis = await this.createRedisClient();
        try {
            return await cb(redis);
        }
        finally {
            await redis.quit();
        }
    }
    async has(baseKey, key) {
        return ((await this.pool.use((r) => r.redis.exists(this.usingKey(baseKey, key)))) !== 0);
    }
    async get(baseKey, key) {
        return this.pool.use((r) => r.redis.getBuffer(this.usingKey(baseKey, key)));
    }
    async set(baseKey, key, value, ttl) {
        const redisKey = this.usingKey(baseKey, key);
        await this.pool.use((r) => {
            if (ttl) {
                return r.redis.set(redisKey, value, 'PX', ttl);
            }
            else {
                return r.redis.set(redisKey, value);
            }
        });
    }
    async del(baseKey, key) {
        return !!(await this.pool.use((r) => r.redis.del(this.usingKey(baseKey, key))));
    }
    originalKeys(baseKey, prefix = '') {
        return this.pool.use((r) => r.redis.keys(this.usingKey(baseKey, `${prefix}*`)));
    }
    async keys(baseKey, prefix) {
        const keys = await this.originalKeys(baseKey, prefix ?? '');
        return keys.map((key) => key.slice(baseKey.length + 1));
    }
    async clear(baseKey, prefix) {
        const keys = await this.originalKeys(baseKey, prefix);
        if (!keys.length) {
            return;
        }
        await this.pool.use((r) => r.redis.del(keys));
    }
    async lock(keys, cb) {
        const run = () => this.useTempRedisClient(async (redis) => {
            const redlock = new redlock_1.Redlock([redis], this.options.lock);
            return redlock.using(keys.map((key) => `${this.options.lock?.prefix || '_lock'}:${key}`), this.options.lock?.duration || 5000, cb);
        });
        if (this.options?.lock?.stacked) {
            return this.betterLock.acquire(keys, run);
        }
        else {
            return run();
        }
    }
    async isFree(keys) {
        const lockKeys = keys.map((key) => `${this.options.lock?.prefix || '_lock'}:${key}`);
        return (await this.pool.use((r) => r.redis.exists(...lockKeys))) === 0;
    }
    async destroy() {
        this.quitted = true;
        [...this.waitingBlockingProms.values()].forEach((resolve) => resolve());
        await this.pool.drain();
    }
    getQueueKey(key) {
        return `${this.options.queueKey || '_queue'}:${key}`;
    }
    getQueueBackupKey(key) {
        return `${this.options.queueBackupKey || '_queue_backup'}:${key}`;
    }
    async queueLength(key) {
        const _key = this.getQueueKey(key);
        return this.pool.use((r) => r.redis.llen(_key));
    }
    async queueItems(key) {
        const _key = this.getQueueKey(key);
        return this.pool.use((r) => r.redis.lrangeBuffer(_key, 0, -1));
    }
    async queueAdd(key, value, prior) {
        const _key = this.getQueueKey(key);
        await this.pool.use(async (r) => {
            if (prior) {
                await r.redis.lpush(_key, value);
            }
            else {
                await r.redis.rpush(_key, value);
            }
        });
    }
    async queueGather(key) {
        const _key = this.getQueueKey(key);
        const backupKey = this.getQueueBackupKey(key);
        const value = await this.pool.use((r) => r.redis.lmoveBuffer(_key, backupKey, 'LEFT', 'RIGHT'));
        return value || undefined;
    }
    async queueGatherBlocking(key) {
        if (this.quitted)
            return;
        const _key = this.getQueueKey(key);
        const backupKey = this.getQueueBackupKey(key);
        const res = await this.useTempRedisClient(async (redisClient) => {
            try {
                const valueProm = redisClient.blmoveBuffer(_key, backupKey, 'LEFT', 'RIGHT', 0);
                const exitProm = new Promise((resolve) => {
                    this.waitingBlockingProms.set(valueProm, resolve);
                });
                const value = await Promise.race([valueProm, exitProm]);
                this.waitingBlockingProms.delete(valueProm);
                if (value)
                    return value;
            }
            catch (e) { }
        });
        return res || this.queueGatherBlocking(key);
    }
    async queueAck(key, value) {
        if (this.quitted)
            return;
        const backupKey = this.getQueueBackupKey(key);
        await this.pool.use((r) => r.redis.lrem(backupKey, 1, value));
    }
    async queueResume(key, value, prior) {
        if (this.quitted)
            return;
        const _key = this.getQueueKey(key);
        const backupKey = this.getQueueBackupKey(key);
        await this.pool.use(async (r) => {
            if (!(await r.redis.lrem(backupKey, 1, value)))
                return;
            if (prior) {
                await r.redis.lpush(_key, value);
            }
            else {
                await r.redis.rpush(_key, value);
            }
        });
    }
    async queueResumeAll(key, prior) {
        if (this.quitted)
            return;
        const _key = this.getQueueKey(key);
        const backupKey = this.getQueueBackupKey(key);
        await this.pool.use(async (r) => {
            const values = await r.redis.lrangeBuffer(backupKey, 0, -1);
            const commands = r.redis.multi().del(backupKey);
            if (prior) {
                values.reverse();
                values.forEach((value) => commands.lpush(_key, value));
            }
            else {
                values.forEach((value) => commands.rpush(_key, value));
            }
            await commands.exec();
        });
    }
    async queueClear(key) {
        const _key = this.getQueueKey(key);
        await this.pool.use((r) => r.redis.del(_key));
    }
}
exports.RedisDriver = RedisDriver;
//# sourceMappingURL=redis.js.map