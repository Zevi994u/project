"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryDriver = void 0;
const lru_cache_1 = __importDefault(require("lru-cache"));
const base_driver_1 = require("../base-driver");
const better_lock_1 = __importDefault(require("better-lock"));
class MemoryDriver extends base_driver_1.BaseDriver {
    constructor() {
        super(...arguments);
        this.cacheMap = new Map();
        this.betterLock = new better_lock_1.default();
        this.queues = new Map();
        this.backupQueues = new Map();
        this.blockingGathers = new Map();
    }
    async destroy() {
        for (const cache of this.cacheMap.values()) {
            cache.clear();
        }
        this.cacheMap.clear();
        this.queues.clear();
        [...this.blockingGathers.values()].forEach((v) => v.forEach((f) => f(undefined)));
        this.blockingGathers.clear();
    }
    getCacheInstance(baseKey) {
        if (!this.cacheMap.has(baseKey)) {
            this.cacheMap.set(baseKey, new lru_cache_1.default({
                ttl: 1,
                updateAgeOnGet: false,
                updateAgeOnHas: false,
            }));
        }
        return this.cacheMap.get(baseKey);
    }
    async get(baseKey, key) {
        const cache = this.getCacheInstance(baseKey);
        return cache.get(key);
    }
    async set(baseKey, key, value, ttl) {
        const cache = this.getCacheInstance(baseKey);
        cache.set(key, value, { ttl });
    }
    async del(baseKey, key) {
        const cache = this.getCacheInstance(baseKey);
        return cache.delete(key);
    }
    async keys(baseKey, prefix) {
        const cache = this.getCacheInstance(baseKey);
        let keys = Array.from(cache.keys());
        if (prefix) {
            keys = keys.filter((key) => key.startsWith(prefix));
        }
        return keys;
    }
    async clear(baseKey, prefix) {
        const cache = this.getCacheInstance(baseKey);
        if (prefix) {
            const keys = Array.from(cache.keys());
            for (const key of keys) {
                if (key.startsWith(prefix)) {
                    cache.delete(key);
                }
            }
        }
        else {
            cache.clear();
        }
    }
    lock(keys, cb) {
        return this.betterLock.acquire(keys, cb);
    }
    async isFree(keys) {
        return keys.every((key) => this.betterLock.canAcquire(key));
    }
    getQueue(key) {
        if (!this.queues.has(key)) {
            this.queues.set(key, []);
        }
        return this.queues.get(key);
    }
    getBackupQueue(key) {
        if (!this.backupQueues.has(key)) {
            this.backupQueues.set(key, []);
        }
        return this.backupQueues.get(key);
    }
    async queueAdd(key, value, prior) {
        if (this.blockingGathers.has(key)) {
            const cb = this.blockingGathers.get(key).shift();
            if (cb) {
                cb(value);
                return;
            }
        }
        const queue = this.getQueue(key);
        if (prior) {
            queue.unshift(value);
        }
        else {
            queue.push(value);
        }
    }
    async queueItems(key) {
        return [...(this.queues.get(key) || [])];
    }
    async queueGather(key) {
        const queue = this.queues.get(key);
        if (!queue.length)
            return;
        const elem = queue.shift();
        const backupQueue = this.getBackupQueue(key);
        backupQueue.push(elem);
        return elem;
    }
    async queueGatherBlocking(key) {
        const itemInQueue = await this.queueGather(key);
        if (itemInQueue)
            return itemInQueue;
        if (!this.blockingGathers.has(key)) {
            this.blockingGathers.set(key, []);
        }
        return new Promise((resolve) => {
            this.blockingGathers.get(key).push(resolve);
        });
    }
    async queueAck(key, value) {
        const backupQueue = this.getBackupQueue(key);
        const idx = backupQueue.findIndex((v) => value.equals(v));
        if (idx === -1)
            return;
        backupQueue.splice(idx, 1);
    }
    async queueResume(key, value, prior) {
        const backupQueue = this.getBackupQueue(key);
        const idx = backupQueue.findIndex((v) => value.equals(v));
        if (idx === -1)
            return;
        backupQueue.splice(idx, 1);
        return this.queueAdd(key, value, prior);
    }
    async queueResumeAll(key, prior) {
        const backupQueue = this.getBackupQueue(key);
        if (prior) {
            backupQueue.reverse();
        }
        for (const value of backupQueue) {
            await this.queueAdd(key, value, prior);
        }
        backupQueue.splice(0, backupQueue.length);
    }
    async queueClear(key) {
        this.queues.delete(key);
    }
}
exports.MemoryDriver = MemoryDriver;
//# sourceMappingURL=memory.js.map